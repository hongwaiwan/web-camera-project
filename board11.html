<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Weiqi Board Canvas with SGF Save & Scoring</title>
<style>
body { margin:0; background:#f0e4c2; display:flex; flex-direction:column; height:100vh; }
#board-container { flex:1; display:flex; justify-content:center; align-items:center; }
#board { background:#deb887; touch-action:none; }
#info { text-align:center; font-size:22px; margin:5px; } /* updated font size */
#controls { padding:10px; text-align:center; background:#e0d2b2; display:flex; flex-wrap:wrap; justify-content:center; }
#controls button { margin:5px; padding:10px 16px; font-size:22px; cursor:pointer; } /* updated font size */
#sgfFile { display:none; }
</style>
</head>
<body>

<div id="board-container">
  <canvas id="board"></canvas>
</div>

<div id="info">Move: 0</div>

<div id="controls">
  <button onclick="goToBegin()">‚èÆ</button>
  <button onclick="stepBackward()">‚óÄ</button>
  <button onclick="stepForward()">‚ñ∂</button>
  <button onclick="goToEnd()">‚è≠</button>
  <button onclick="undoMove()">‚Ü©</button>
  <button onclick="cleanBoard()">üÜï New</button>
  <button id="toggleMode" onclick="toggleMode()">üìä Score</button>
  <button onclick="document.getElementById('sgfFile').click()">üìÇ Open</button>
  <input type="file" id="sgfFile" accept=".sgf" style="display:none;">
  <button onclick="saveSGF()">üíæ Save</button>
</div>

<script>
const size = 19;
let grid = Array.from({length:size},()=>Array(size).fill(null));
let moveList = [];
let currentMove = 0;
let koHistory = new Set();
let userDeadGroups = new Set();
let scoringMode = false;
let canvas = document.getElementById("board");
let ctx = canvas.getContext("2d");
let currentFileName = "";

// --- Resize & Draw ---
function resizeBoard(){ 
  const w=Math.min(window.innerWidth, window.innerHeight*.9); 
  canvas.width=canvas.height=w; 
  drawBoard(); 
  adjustButtonsLayout();
}

function drawBoard(){
  const w=canvas.width, h=canvas.height;
  const spacing=w/(size-1+1), padding=spacing/2;
  ctx.clearRect(0,0,w,h);

  // Grid
  ctx.strokeStyle="#000"; ctx.lineWidth=1;
  for(let i=0;i<size;i++){
    ctx.beginPath(); ctx.moveTo(Math.round(padding+i*spacing), Math.round(padding)); ctx.lineTo(Math.round(padding+i*spacing), Math.round(h-padding)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(Math.round(padding), Math.round(padding+i*spacing)); ctx.lineTo(Math.round(w-padding), Math.round(padding+i*spacing)); ctx.stroke();
  }

  // Star points
  const stars=[[3,3],[3,9],[3,15],[9,3],[9,9],[9,15],[15,3],[15,9],[15,15]];
  const starRadius = Math.max(3, Math.min(5, Math.floor(Math.min(canvas.width, canvas.height)/200)));
  stars.forEach(([r,c])=>{ctx.beginPath(); ctx.arc(Math.round(padding+c*spacing),Math.round(padding+r*spacing),starRadius,0,2*Math.PI); ctx.fillStyle="#000"; ctx.fill();});

  // Stones
  for(let r=0;r<size;r++){for(let c=0;c<size;c++){if(grid[r][c]) drawStone(r,c,grid[r][c],spacing,padding);}}

  // Last move ring
  if(!scoringMode && currentMove>0){
    const last = moveList[currentMove-1];
    ctx.beginPath();
    ctx.arc(padding+last.col*spacing, padding+last.row*spacing, spacing*0.45/2,0,2*Math.PI);
    ctx.lineWidth=2; ctx.strokeStyle=last.color==="B"?"white":"black"; ctx.stroke();
  }

  // Dead stones overlay
  if(scoringMode){ drawScoringOverlay(); }

  canvas.dataset.spacing = spacing; canvas.dataset.padding = padding;

  // Info
  let infoText = "Move: " + currentMove;
  if (scoringMode) {
    const score = computeScoreChinese();
    infoText += " | Score - Black " + score.black + " (" + (score.black - score.white) + ") : White " + score.white;
  }
  if (currentFileName) infoText += " | File: " + currentFileName;
  document.getElementById("info").innerText = infoText;
}

function drawStone(r,c,color,spacing,padding){
  const x=padding+c*spacing, y=padding+r*spacing, radius=spacing*0.45;
  ctx.shadowColor="rgba(0,0,0,0.4)"; ctx.shadowBlur=6; ctx.shadowOffsetX=radius*0.15; ctx.shadowOffsetY=radius*0.15;
  const grad = ctx.createRadialGradient(x-radius*0.3,y-radius*0.3,radius*0.1,x,y,radius);
  if(color==="B"){grad.addColorStop(0,"#666"); grad.addColorStop(1,"#000");}else{grad.addColorStop(0,"#fff"); grad.addColorStop(1,"#ccc");}
  ctx.beginPath(); ctx.arc(x,y,radius,0,2*Math.PI); ctx.fillStyle=grad; ctx.fill();
  ctx.shadowBlur=0; ctx.shadowOffsetX=0; ctx.shadowOffsetY=0;
  if(color==="W"){ctx.strokeStyle="#888"; ctx.lineWidth=1; ctx.stroke();}
}

// --- Buttons Layout for portrait/landscape ---
function adjustButtonsLayout(){
  const controls = document.getElementById("controls");
  const buttons = Array.from(controls.getElementsByTagName("button"));
  const isPortrait = window.innerHeight > window.innerWidth;

  controls.style.flexWrap = "wrap";
  if(isPortrait){
    // Portrait: 2 rows
    buttons.forEach((btn,i)=>{
      if(i<5){ btn.style.flex = "1 1 calc(20% - 10px)"; } // first row 5 buttons
      else{ btn.style.flex = "1 1 calc(25% - 10px)"; }   // second row remaining 5 buttons
    });
  } else {
    // Landscape: 1 row
    buttons.forEach(btn=>{ btn.style.flex = "1 1 calc(10% - 10px)"; });
  }

  // font size same for both modes
  buttons.forEach(btn=>btn.style.fontSize="22px");
  document.getElementById("info").style.fontSize="22px";
}

// --- Rest of your existing code for moves, scoring, SGF, etc. ---
function undoMove(){if(moveList.length>0){moveList.pop(); currentMove=moveList.length; applyMoves();}}
function cleanBoard(){
  moveList = []; currentMove = 0; grid = Array.from({length:size},()=>Array(size).fill(null));
  koHistory.clear(); userDeadGroups.clear(); scoringMode = false; 
  document.getElementById("toggleMode").innerText = "üìä Score"; currentFileName = ""; drawBoard();
}
function stepBackward(){if(currentMove>0){currentMove--; applyMoves();}}
function stepForward(){if(currentMove<moveList.length){currentMove++; applyMoves();}}
function goToBegin(){currentMove=0; applyMoves();}
function goToEnd(){currentMove=moveList.length; applyMoves();}
function toggleMode(){ scoringMode=!scoringMode; document.getElementById("toggleMode").innerText=scoringMode?"‚úèÔ∏è Play":"üìä Score"; if(scoringMode) autoDetectDeadGroups(); drawBoard(); }

// SGF open/save
document.getElementById("sgfFile").addEventListener("change", function(e) {
  const file = e.target.files[0]; if(!file) return;
  moveList = []; currentMove = 0; grid = Array.from({length:size},()=>Array(size).fill(null));
  koHistory.clear(); userDeadGroups.clear(); scoringMode=false;
  document.getElementById("toggleMode").innerText="üìä Score"; currentFileName=file.name;
  const reader = new FileReader();
  reader.onload = function(ev){ parseSGF(ev.target.result); currentMove=moveList.length; drawBoard(); }
  reader.readAsText(file); e.target.value=null;
});
function parseSGF(sgf){ moveList=[]; currentMove=0; const regex=/;([BW])\[([a-s]{2})\]/g; let match; while(match=regex.exec(sgf)){ const color=match[1]; const [c,r]=match[2].split("").map(ch=>ch.charCodeAt(0)-97); moveList.push({row:r,col:c,color}); } currentMove=moveList.length; applyMoves(); }
function saveSGF(){ let sgf="(;FF[4]GM[1]SZ[19]"; moveList.forEach(m=>{ const c=String.fromCharCode(97+m.col); const r=String.fromCharCode(97+m.row); sgf+=`;${m.color}[${c}${r}]`;}); sgf+=")"; const blob=new Blob([sgf],{type:"text/plain"}); const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="game.sgf"; a.click(); URL.revokeObjectURL(url); }

// Your existing applyMoves(), scoring functions, drawDeadMarkGroup(), etc. can remain unchanged

window.addEventListener("resize",resizeBoard);
resizeBoard();
</script>

</body>
</html>
